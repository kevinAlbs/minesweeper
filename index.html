<html>

<head>
    <style type="text/css">
        canvas {
            border: 1px black solid;
        }
    </style>
</head>

<body>
    <canvas width="506" height="370"></canvas>
</body>
<script>
    // Minesweeper expert mode is 16x30.
    // Begin game logic. Uses grid. Uses sprite_map.
    const game_make = function () {
        const obj = {};
        const cnv = document.querySelector("canvas");
        const ctx = cnv.getContext("2d");
        const grid_top = 10;
        const grid_left = 0;
        let grid = grid_make(16, 30);

        const mouse = {
            in_canvas: false,
            buttons: 0,
            offsetX: 0,
            offsetY: 0
        };
        let mouseReleased = false; // Set to false after processed in a tick.

        document.addEventListener("mousemove", function (e) {
            if (e.target == cnv) {
                mouse.in_canvas = true;
                mouse.offsetX = e.offsetX;
                mouse.offsetY = e.offsetY;
                mouse.buttons = e.buttons;
            } else {
                mouse.in_canvas = false;
                mouse.offsetX = 0;
                mouse.offsetY = 0;
                mouse.buttons = 0;
            }
        });

        cnv.addEventListener("mouseup", function (e) {
            mouseReleased = true;
        });

        obj.start = function () {
            window.requestAnimationFrame(loop);
        }

        // get_cell_coords returns the coordinates of a cell from a mouse position
        function get_cell_coords(mouse_x, mouse_y) {
            mouse_y -= grid_top;
            mouse_x -= grid_left;
            const i = Math.floor(mouse_y / 16);
            const j = Math.floor(mouse_x / 16);
            if (i < 0 || i >= grid.length) {
                return null;
            }
            if (j < 0 || j >= grid[0].length) {
                return null;
            }
            return { i: i, j: j };
        }

        function loop() {
            // Render grid.
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    ctx.drawImage(sprite_map["cell"], grid_left + 16 * j, grid_top + 16 * i);
                }
            }

            if (mouse.buttons & 1) {
                console.log("Primary mouse button is pressed")
                // Primary mouse button pressed.
                const coords = get_cell_coords(mouse.offsetX, mouse.offsetY);
                if (coords) {
                    ctx.drawImage(sprite_map["cell_pressed"], grid_left + 16 * coords.j, grid_top + 16 * coords.i);
                }
            }
            window.requestAnimationFrame(loop);
        }

        function test_get_cell() {
            grid = grid_make(2, 2);
            function eq(a, b) {
                if ((a === null) && (b === null)) return true;
                if ((a === null) != (b === null)) return false;
                return a.i == b.i && a.j == b.j;
            }
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 15), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 16), { i: 1, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 15, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 32, grid_top + 0), null));
        }
        obj.selftest = function () {
            test_get_cell();
        }

        return obj;
    }

    let game = null;

    // Begin loading sprite map.
    const sprite_map = {};
    (function () {
        const image = new Image();
        // Wait for the sprite sheet to load
        image.onload = () => {
            const ps = [];
            // Cut two rows of 16x16 squares.
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 8; j++) {
                    ps.push(createImageBitmap(image, 17 * j, 49 + 17 * i, 16, 16));
                }
            }
            // Cut row of smileys.
            for (let i = 0; i < 5; i++) {
                ps.push(createImageBitmap(image, 25 * i, 24, 24, 24));
            }
            // Cut row of digits.
            for (let i = 0; i < 12; i++) {
                ps.push(createImageBitmap(image, 14 * i, 0, 13, 23));
            }
            Promise.all(ps).then((sprites) => {
                const sprite_names = [
                    "cell", "cell_pressed", "flag", "question", "question_pressed", "mine", "mine_red", "mine_x", "1", "2", "3", "4", "5", "6", "7", "8", "smiley", "smiley_pressed", "smiley_o", "smiley_glasses", "smiley_dead", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d0", "ddash", "dempty"
                ];
                // Draw each sprite onto the canvas
                console.assert(sprite_names.length == sprites.length);
                for (let i = 0; i < sprite_names.length; i++) {
                    sprite_map[sprite_names[i]] = sprites[i];
                }
                game = game_make();
                game.start();
            });

        };

        image.onerror = () => {
            console.error("Failed to load spritesheet image");
        }

        // Load the sprite sheet from an image file
        image.src = "spritesheet.png";
    }());

    // Begin grid logic. Does not interact with UI.
    const kCellStateUnopened = 0;
    const kCellStateOpened = 1;
    const kCellStateFlagged = 2;

    // grid_make makes a grid with no mines.
    function grid_make(n_rows, n_cols) {
        const grid = [];
        for (let i = 0; i < n_rows; i++) {
            const row = [];
            for (let j = 0; j < n_cols; j++) {
                const cell = {
                    state: kCellStateUnopened,
                    is_mine: false
                };
                row.push(cell);
            }
            grid.push(row)
        }
        // Loop again, and make links to neighbors.
        for (let i = 0; i < n_rows; i++) {
            for (let j = 0; j < n_cols; j++) {
                const cell = grid[i][j];
                grid[i][j].nw = i > 0 && j > 0 ? grid[i - 1][j - 1] : null;
                grid[i][j].n = i > 0 ? grid[i - 1][j] : null;
                grid[i][j].ne = i > 0 && j < n_cols - 1 ? grid[i - 1][j + 1] : null;

                grid[i][j].w = j > 0 ? grid[i][j - 1] : null;
                grid[i][j].e = j < n_cols - 1 ? grid[i][j + 1] : null;

                grid[i][j].sw = i < n_rows - 1 && j > 0 ? grid[i + 1][j - 1] : null;
                grid[i][j].s = i < n_rows - 1 ? grid[i + 1][j] : null;
                grid[i][j].se = i < n_rows - 1 && j < n_cols - 1 ? grid[i + 1][j + 1] : null;
            }
        }
        return grid;
    };

    function shuffle(arr) {
        for (let i = 0; i < arr.length; i++) {
            let dst = Math.floor(Math.random() * arr.length);
            let tmp = arr[dst];
            arr[dst] = arr[i];
            arr[i] = tmp;
        }
    }

    // grid_set_mines adds num_mines randomly. start_i and start_j are excluded from consideration.
    function grid_set_mines(grid, start_i, start_j, num_mines) {
        const num_rows = grid.length;
        const num_cols = grid[0].length;

        console.assert(num_mines <= num_rows * num_cols - 1);
        let positions = [];
        for (let i = 0; i < num_rows; i++) {
            for (let j = 0; j < num_cols; j++) {
                if (i == start_i && j == start_j) {
                    continue;
                }
                positions.push({ i: i, j: j });
            }
        }
        shuffle(positions);
        for (let m = 0; m < num_mines; m++) {
            grid[positions[m].i][positions[m].j].is_mine = true;
        }
    }

    const kGridStateInProgress = 0;
    const kGridStateWon = 1;
    const kGridStateLost = 2;
    function grid_state(grid) {
        let num_mines = 0;
        let num_open = 0;
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                let cell = grid[i][j];
                if (cell.state == kCellStateOpened && cell.is_mine) {
                    return kGridStateLost;
                }
                if (cell.state == kCellStateOpened) {
                    num_open++;
                }
                if (cell.is_mine) {
                    num_mines++;
                }
            }
        }
        let num_cells = grid.length * grid[0].length;
        return num_cells - num_open == num_mines;
    }

    function cell_mine_count(cell) {
        console.assert(!cell.is_mine);
        let count = 0;
        if (cell.ne && cell.ne.is_mine) count++;
        if (cell.n && cell.n.is_mine) count++;
        if (cell.nw && cell.nw.is_mine) count++;
        if (cell.w && cell.w.is_mine) count++;
        if (cell.e && cell.e.is_mine) count++;
        if (cell.se && cell.se.is_mine) count++;
        if (cell.s && cell.s.is_mine) count++;
        if (cell.sw && cell.sw.is_mine) count++;
        return count;
    }

    function cell_flag_count(cell) {
        let count = 0;
        if (cell.ne && cell.ne.state == kCellStateFlagged) count++;
        if (cell.n && cell.n.state == kCellStateFlagged) count++;
        if (cell.nw && cell.nw.state == kCellStateFlagged) count++;
        if (cell.w && cell.w.state == kCellStateFlagged) count++;
        if (cell.e && cell.e.state == kCellStateFlagged) count++;
        if (cell.se && cell.se.state == kCellStateFlagged) count++;
        if (cell.s && cell.s.state == kCellStateFlagged) count++;
        if (cell.sw && cell.sw.state == kCellStateFlagged) count++;
        return count;
    }

    // cell_reveal returns false if cell is a is_mine.
    function cell_reveal(cell) {
        if (cell.state == kCellStateOpened) {
            // Already revealed. Do nothing.
            return true;
        }
        if (cell.state == kCellStateFlagged) {
            // Flagged cells cannot be revealed without unflagging. Do nothing.
            return true;
        }

        cell.state = kCellStateOpened;
        if (cell.is_mine) {
            return false;
        }

        // If no neighbors are mines, reveal all neighbors.
        if (cell_mine_count(cell) != 0) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) cell_reveal(cell.ne);
        if (cell.n && cell.n.state == kCellStateUnopened) cell_reveal(cell.n);
        if (cell.nw && cell.nw.state == kCellStateUnopened) cell_reveal(cell.nw);
        if (cell.w && cell.w.state == kCellStateUnopened) cell_reveal(cell.w);
        if (cell.e && cell.e.state == kCellStateUnopened) cell_reveal(cell.e);
        if (cell.se && cell.se.state == kCellStateUnopened) cell_reveal(cell.se);
        if (cell.s && cell.s.state == kCellStateUnopened) cell_reveal(cell.s);
        if (cell.sw && cell.sw.state == kCellStateUnopened) cell_reveal(cell.sw);
        return true;
    }

    // cell_chord attempts to reveal cells if the number of flagged neighbors equals the number of neighboring mines.
    // returns false if a revealed cell is a is_mine.
    // does nothing if the number of flagged neighbors is not equal to the number of neighboring mines.
    function cell_chord(cell) {
        if (cell.state != kCellStateOpened) {
            // Not open. Do nothing.
            return true;
        }

        if (cell_mine_count(cell) != cell_flag_count(cell)) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) { if (!cell_reveal(cell.ne)) return false; }
        if (cell.n && cell.n.state == kCellStateUnopened) { if (!cell_reveal(cell.n)) return false; }
        if (cell.nw && cell.nw.state == kCellStateUnopened) { if (!cell_reveal(cell.nw)) return false; }
        if (cell.w && cell.w.state == kCellStateUnopened) { if (!cell_reveal(cell.w)) return false; }
        if (cell.e && cell.e.state == kCellStateUnopened) { if (!cell_reveal(cell.e)) return false; }
        if (cell.se && cell.se.state == kCellStateUnopened) { if (!cell_reveal(cell.se)) return false; }
        if (cell.s && cell.s.state == kCellStateUnopened) { if (!cell_reveal(cell.s)) return false; }
        if (cell.sw && cell.sw.state == kCellStateUnopened) { if (!cell_reveal(cell.sw)) return false; }
        return true;
    }


    // Testing ... begin

    function test_grid_make() {
        const grid = grid_make(3, 3);
        console.assert(grid[1][1].nw == grid[0][0]);
        console.assert(grid[1][1].n == grid[0][1]);
        console.assert(grid[1][1].ne == grid[0][2]);
        console.assert(grid[1][1].w == grid[1][0]);
        console.assert(grid[1][1].e == grid[1][2]);
        console.assert(grid[1][1].sw == grid[2][0]);
        console.assert(grid[1][1].s == grid[2][1]);
        console.assert(grid[1][1].se == grid[2][2]);
    }

    // ch2state maps a character to a cell state.
    const ch2state = {
        "u": kCellStateUnopened,
        "o": kCellStateOpened,
        "f": kCellStateFlagged
    };

    // state2ch maps a cell state to a character.
    let state2ch = {};
    for (k in ch2state) {
        let v = ch2state[k];
        state2ch[v] = k;
    }

    function grid2str(grid) {
        let ret = "";
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                ret += state2ch[grid[i][j].state];
            }
            ret += "\n";
        }
        return ret;
    }

    function assert_states(grid, expected_states) {
        console.assert(grid.length == expected_states.length, "Expected expected_states.length == %d. Bad test input?", grid.length);
        for (let i = 0; i < grid.length; i++) {
            console.assert(grid[i].length == expected_states[i].length, "Expected expected_states[%d].length == %d. Bad test input?", i, grid[i].length);
            for (let j = 0; j < grid[i].length; j++) {
                let expected_state_ch = expected_states[i][j];
                console.assert(expected_state_ch in ch2state, "Expected state %s to be in %o", expected_state_ch, Object.keys(ch2state));
                let expected_state = ch2state[expected_state_ch];
                console.assert(grid[i][j].state == expected_state, "Expected (%d, %d) to be state %s, got %s\nExpected Grid\n%s\nGot Grid:\n%s\n", i, j, expected_state_ch, state2ch[grid[i][j].state], expected_states.join("\n"), grid2str(grid));
            }
        }
    }

    function test_reveal() {
        // Reveal returns false on a mine, true on non-mine.
        {
            const grid = grid_make(3, 3);
            grid[0][0].is_mine = true;
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(cell_reveal(grid[1][0]));
        }
        // Reveal recursively reveals.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            assert_states(grid, [
                "uu",
                "uu",
                "uu"
            ]);
            console.assert(cell_reveal(grid[2][1]));
            assert_states(grid, [
                "uu",
                "oo",
                "oo"
            ]);
        }
    }

    function test_chord() {
        // Chord does nothing if no flagged neighbors.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
            // Attempting to chord does nothing.
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
        }
        // Chord reveals if number of flagged neighbors is equal to number of mines.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "uu",
                "uu"
            ]);
            // After flagging the mine, chording reveals.
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "oo",
                "uu"
            ]);
            // Chord works again.
            console.assert(cell_chord(grid[1][1]));
            assert_states(grid, [
                "fo",
                "oo",
                "oo"
            ]);
        }

        // Chord returns false if a mine is revealed.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "uo",
                "fu",
                "uu"
            ]);
            // After flagging the incorrect mine, chording reveals and returns false.
            console.assert(!cell_chord(grid[0][1]));
            assert_states(grid, [
                "oo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not reveal neighbors if number of flagged neighbors is greater than number of mines.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not recursively chord.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            grid[1][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "fo",
                "uu"
            ]);
        }
    }

    function test_grid_state() {
        // Grid is won once all non-mine cells are revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(cell_reveal(grid[0][1]));
            console.assert(cell_reveal(grid[1][0]));
            console.assert(cell_reveal(grid[1][1]));
            console.assert(grid_state(grid) == kGridStateWon);
        }
        // Grid is lost once a mine cells is revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(grid_state(grid) == kGridStateLost);
        }
    }

    function test_grid_set_mines() {
        // Mines are not set on starting position.
        {
            const grid = grid_make(2, 2);
            grid_set_mines(grid, 0, 0, 3);
            console.assert(!grid[0][0].is_mine);
            console.assert(grid[1][0].is_mine);
            console.assert(grid[0][1].is_mine);
            console.assert(grid[1][1].is_mine);
        }
    }


    function run_tests() {
        test_grid_make();
        test_reveal();
        test_chord();
        test_grid_state();
        test_grid_set_mines();
        let g = game_make();
        g.selftest();
    }

    run_tests();

    // Testing ... end
</script>

</html>