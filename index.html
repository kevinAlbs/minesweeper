<html>

<head>
    <style type="text/css">
        canvas {
            border: 1px black solid;
        }
    </style>
</head>

<body>
    <canvas width="506" height="370"></canvas>
</body>
<script>
    // Minesweeper expert mode is 16x30.

    // Begin UI.
    const cnv = document.querySelector("canvas");
    const ctx = cnv.getContext("2d");
    const image = new Image();
    const sprites = {};

    // Wait for the sprite sheet to load
    image.onload = () => {
        const ps = [];
        // Cut two rows of 16x16 squares.
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 8; j++) {
                ps.push(createImageBitmap(image, 17 * j, 49 + 17 * i, 16, 16));
            }
        }
        // Cut row of smileys.
        for (let i = 0; i < 5; i++) {
            ps.push(createImageBitmap(image, 25 * i, 24, 24, 24));
        }
        // Cut row of digits.
        for (let i = 0; i < 12; i++) {
            ps.push(createImageBitmap(image, 14 * i, 0, 13, 23));
        }
        Promise.all(ps).then((sprites) => {
            // Draw each sprite onto the canvas
            sprites["cell"] = sprites[0];
            sprites["cell_pressed"] = sprites[1];
            sprites["flag"] = sprites[2];

            for (i = 0; i < 16; i++) {
                ctx.drawImage(sprites[i], 20 * i, 16);
            }

            for (i = 16; i < 16 + 5; i++) {
                ctx.drawImage(sprites[i], 25 * (i - 16), 40);
            }

            for (i = 16 + 5; i < 16 + 5 + 12; i++) {
                ctx.drawImage(sprites[i], 15 * (i - 16 - 5), 80);
            }
        });
    };

    image.onerror = () => {
        console.error("Failed to load spritesheet image");
    }

    // Load the sprite sheet from an image file
    image.src = "spritesheet.png";


    // Begin game logic. Does not interact with UI.
    const kCellStateUnopened = 0;
    const kCellStateOpened = 1;
    const kCellStateFlagged = 2;

    // grid_make makes a grid with no mines.
    function grid_make(n_rows, n_cols) {
        const grid = [];
        for (let i = 0; i < n_rows; i++) {
            const row = [];
            for (let j = 0; j < n_cols; j++) {
                const cell = {
                    state: kCellStateUnopened,
                    is_mine: false
                };
                row.push(cell);
            }
            grid.push(row)
        }
        // Loop again, and make links to neighbors.
        for (let i = 0; i < n_rows; i++) {
            for (let j = 0; j < n_cols; j++) {
                const cell = grid[i][j];
                grid[i][j].nw = i > 0 && j > 0 ? grid[i - 1][j - 1] : null;
                grid[i][j].n = i > 0 ? grid[i - 1][j] : null;
                grid[i][j].ne = i > 0 && j < n_cols - 1 ? grid[i - 1][j + 1] : null;

                grid[i][j].w = j > 0 ? grid[i][j - 1] : null;
                grid[i][j].e = j < n_cols - 1 ? grid[i][j + 1] : null;

                grid[i][j].sw = i < n_rows - 1 && j > 0 ? grid[i + 1][j - 1] : null;
                grid[i][j].s = i < n_rows - 1 ? grid[i + 1][j] : null;
                grid[i][j].se = i < n_rows - 1 && j < n_cols - 1 ? grid[i + 1][j + 1] : null;
            }
        }
        return grid;
    };

    function shuffle(arr) {
        for (let i = 0; i < arr.length; i++) {
            let dst = Math.floor(Math.random() * arr.length);
            let tmp = arr[dst];
            arr[dst] = arr[i];
            arr[i] = tmp;
        }
    }

    // grid_set_mines adds num_mines randomly. start_i and start_j are excluded from consideration.
    function grid_set_mines(grid, start_i, start_j, num_mines) {
        const num_rows = grid.length;
        const num_cols = grid[0].length;

        console.assert(num_mines <= num_rows * num_cols - 1);
        let positions = [];
        for (let i = 0; i < num_rows; i++) {
            for (let j = 0; j < num_cols; j++) {
                if (i == start_i && j == start_j) {
                    continue;
                }
                positions.push({ i: i, j: j });
            }
        }
        shuffle(positions);
        for (let m = 0; m < num_mines; m++) {
            grid[positions[m].i][positions[m].j].is_mine = true;
        }
    }

    const kGridStateInProgress = 0;
    const kGridStateWon = 1;
    const kGridStateLost = 2;
    function grid_state(grid) {
        let num_mines = 0;
        let num_open = 0;
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                let cell = grid[i][j];
                if (cell.state == kCellStateOpened && cell.is_mine) {
                    return kGridStateLost;
                }
                if (cell.state == kCellStateOpened) {
                    num_open++;
                }
                if (cell.is_mine) {
                    num_mines++;
                }
            }
        }
        let num_cells = grid.length * grid[0].length;
        return num_cells - num_open == num_mines;
    }

    function cell_mine_count(cell) {
        console.assert(!cell.is_mine);
        let count = 0;
        if (cell.ne && cell.ne.is_mine) count++;
        if (cell.n && cell.n.is_mine) count++;
        if (cell.nw && cell.nw.is_mine) count++;
        if (cell.w && cell.w.is_mine) count++;
        if (cell.e && cell.e.is_mine) count++;
        if (cell.se && cell.se.is_mine) count++;
        if (cell.s && cell.s.is_mine) count++;
        if (cell.sw && cell.sw.is_mine) count++;
        return count;
    }

    function cell_flag_count(cell) {
        let count = 0;
        if (cell.ne && cell.ne.state == kCellStateFlagged) count++;
        if (cell.n && cell.n.state == kCellStateFlagged) count++;
        if (cell.nw && cell.nw.state == kCellStateFlagged) count++;
        if (cell.w && cell.w.state == kCellStateFlagged) count++;
        if (cell.e && cell.e.state == kCellStateFlagged) count++;
        if (cell.se && cell.se.state == kCellStateFlagged) count++;
        if (cell.s && cell.s.state == kCellStateFlagged) count++;
        if (cell.sw && cell.sw.state == kCellStateFlagged) count++;
        return count;
    }

    // cell_reveal returns false if cell is a is_mine.
    function cell_reveal(cell) {
        if (cell.state == kCellStateOpened) {
            // Already revealed. Do nothing.
            return true;
        }
        if (cell.state == kCellStateFlagged) {
            // Flagged cells cannot be revealed without unflagging. Do nothing.
            return true;
        }

        cell.state = kCellStateOpened;
        if (cell.is_mine) {
            return false;
        }

        // If no neighbors are mines, reveal all neighbors.
        if (cell_mine_count(cell) != 0) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) cell_reveal(cell.ne);
        if (cell.n && cell.n.state == kCellStateUnopened) cell_reveal(cell.n);
        if (cell.nw && cell.nw.state == kCellStateUnopened) cell_reveal(cell.nw);
        if (cell.w && cell.w.state == kCellStateUnopened) cell_reveal(cell.w);
        if (cell.e && cell.e.state == kCellStateUnopened) cell_reveal(cell.e);
        if (cell.se && cell.se.state == kCellStateUnopened) cell_reveal(cell.se);
        if (cell.s && cell.s.state == kCellStateUnopened) cell_reveal(cell.s);
        if (cell.sw && cell.sw.state == kCellStateUnopened) cell_reveal(cell.sw);
        return true;
    }

    // cell_chord attempts to reveal cells if the number of flagged neighbors equals the number of neighboring mines.
    // returns false if a revealed cell is a is_mine.
    // does nothing if the number of flagged neighbors is not equal to the number of neighboring mines.
    function cell_chord(cell) {
        if (cell.state != kCellStateOpened) {
            // Not open. Do nothing.
            return true;
        }

        if (cell_mine_count(cell) != cell_flag_count(cell)) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) { if (!cell_reveal(cell.ne)) return false; }
        if (cell.n && cell.n.state == kCellStateUnopened) { if (!cell_reveal(cell.n)) return false; }
        if (cell.nw && cell.nw.state == kCellStateUnopened) { if (!cell_reveal(cell.nw)) return false; }
        if (cell.w && cell.w.state == kCellStateUnopened) { if (!cell_reveal(cell.w)) return false; }
        if (cell.e && cell.e.state == kCellStateUnopened) { if (!cell_reveal(cell.e)) return false; }
        if (cell.se && cell.se.state == kCellStateUnopened) { if (!cell_reveal(cell.se)) return false; }
        if (cell.s && cell.s.state == kCellStateUnopened) { if (!cell_reveal(cell.s)) return false; }
        if (cell.sw && cell.sw.state == kCellStateUnopened) { if (!cell_reveal(cell.sw)) return false; }
        return true;
    }


    // Testing ... begin

    function test_grid_make() {
        const grid = grid_make(3, 3);
        console.assert(grid[1][1].nw == grid[0][0]);
        console.assert(grid[1][1].n == grid[0][1]);
        console.assert(grid[1][1].ne == grid[0][2]);
        console.assert(grid[1][1].w == grid[1][0]);
        console.assert(grid[1][1].e == grid[1][2]);
        console.assert(grid[1][1].sw == grid[2][0]);
        console.assert(grid[1][1].s == grid[2][1]);
        console.assert(grid[1][1].se == grid[2][2]);
    }

    // ch2state maps a character to a cell state.
    const ch2state = {
        "u": kCellStateUnopened,
        "o": kCellStateOpened,
        "f": kCellStateFlagged
    };

    // state2ch maps a cell state to a character.
    let state2ch = {};
    for (k in ch2state) {
        let v = ch2state[k];
        state2ch[v] = k;
    }

    function grid2str(grid) {
        let ret = "";
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                ret += state2ch[grid[i][j].state];
            }
            ret += "\n";
        }
        return ret;
    }

    function assert_states(grid, expected_states) {
        console.assert(grid.length == expected_states.length, "Expected expected_states.length == %d. Bad test input?", grid.length);
        for (let i = 0; i < grid.length; i++) {
            console.assert(grid[i].length == expected_states[i].length, "Expected expected_states[%d].length == %d. Bad test input?", i, grid[i].length);
            for (let j = 0; j < grid[i].length; j++) {
                let expected_state_ch = expected_states[i][j];
                console.assert(expected_state_ch in ch2state, "Expected state %s to be in %o", expected_state_ch, Object.keys(ch2state));
                let expected_state = ch2state[expected_state_ch];
                console.assert(grid[i][j].state == expected_state, "Expected (%d, %d) to be state %s, got %s\nExpected Grid\n%s\nGot Grid:\n%s\n", i, j, expected_state_ch, state2ch[grid[i][j].state], expected_states.join("\n"), grid2str(grid));
            }
        }
    }

    function test_reveal() {
        // Reveal returns false on a mine, true on non-mine.
        {
            const grid = grid_make(3, 3);
            grid[0][0].is_mine = true;
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(cell_reveal(grid[1][0]));
        }
        // Reveal recursively reveals.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            assert_states(grid, [
                "uu",
                "uu",
                "uu"
            ]);
            console.assert(cell_reveal(grid[2][1]));
            assert_states(grid, [
                "uu",
                "oo",
                "oo"
            ]);
        }
    }

    function test_chord() {
        // Chord does nothing if no flagged neighbors.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
            // Attempting to chord does nothing.
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
        }
        // Chord reveals if number of flagged neighbors is equal to number of mines.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "uu",
                "uu"
            ]);
            // After flagging the mine, chording reveals.
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "oo",
                "uu"
            ]);
            // Chord works again.
            console.assert(cell_chord(grid[1][1]));
            assert_states(grid, [
                "fo",
                "oo",
                "oo"
            ]);
        }

        // Chord returns false if a mine is revealed.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "uo",
                "fu",
                "uu"
            ]);
            // After flagging the incorrect mine, chording reveals and returns false.
            console.assert(!cell_chord(grid[0][1]));
            assert_states(grid, [
                "oo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not reveal neighbors if number of flagged neighbors is greater than number of mines.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not recursively chord.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            grid[1][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]));
            assert_states(grid, [
                "fo",
                "fo",
                "uu"
            ]);
        }
    }

    function test_grid_state() {
        // Grid is won once all non-mine cells are revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(cell_reveal(grid[0][1]));
            console.assert(cell_reveal(grid[1][0]));
            console.assert(cell_reveal(grid[1][1]));
            console.assert(grid_state(grid) == kGridStateWon);
        }
        // Grid is lost once a mine cells is revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(grid_state(grid) == kGridStateLost);
        }
    }

    function test_grid_set_mines() {
        // Mines are not set on starting position.
        {
            const grid = grid_make(2, 2);
            grid_set_mines(grid, 0, 0, 3);
            console.assert(!grid[0][0].is_mine);
            console.assert(grid[1][0].is_mine);
            console.assert(grid[0][1].is_mine);
            console.assert(grid[1][1].is_mine);
        }
    }


    function run_tests() {
        test_grid_make();
        test_reveal();
        test_chord();
        test_grid_state();
        test_grid_set_mines();
    }

    run_tests();

    // Testing ... end
</script>

</html>