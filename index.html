<html>

<head>
    <style type="text/css">
        * {
            padding: 0;
            margin: 0;
            font-family: sans-serif;
            font-size: 10pt;
        }

        canvas {
            margin: 10px auto;
            display: block;
            border: 1px #808080 solid;
        }

        #container {
            margin: 10px auto;
        }

        #config {
            background: white;
            background: #c0c0c0;
            display: none;
            padding: 10px;
            position: relative;
            padding: 20px 10px 10px 10px;
        }

        #config_close {
            position: absolute;
            right: 10px;
            top: 5px;
        }

        #config .options {
            padding-left: 10px;
        }

        #config label {
            position: relative;
            left: 3px;
            top: -1px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas width="504" height="323"></canvas>
        <p><a href="#" id="config_open">Open Settings</a></p>
        <div id="config">
            <a href="#" id="config_close">Close</a>
            <h1>Use secondary mouse click for chording?</h1>
            <div class="options">
                <input type="radio" name="secondary_chording" value="only_secondary" checked="checked"
                    id="secondary_chording_only_secondary"><label for="secondary_chording_only_secondary">Only
                    secondary
                    (convenient for track pads)</label><br />
                <input type="radio" name="secondary_chording" value="both" id="secondary_chording_both"><label
                    for="secondary_chording_both">Both primary and secondary
                    (traditional)</label>
            </div>
            <h1>Difficulty</h1>
            <div class="options">
                <input type="radio" name="difficulty" value="Beginner" id="difficulty_Beginner"><label
                    for="difficulty_Beginner">Beginner</label><br />
                <input type="radio" name="difficulty" value="Intermediate" id="difficulty_Intermediate"><label
                    for="difficulty_Intermediate">Intermediate</label><br />
                <input type="radio" name="difficulty" value="Expert" id="difficulty_Expert" checked="checked"><label
                    for="difficulty_Expert">Expert</label><br />
            </div>
        </div>
        <small>View the source on <a href="https://github.com/kevinAlbs/minesweeper" target="_blank">Github</a></small>
    </div>
</body>
<script>
    const config = {
        secondary_chording: "only_secondary",
        difficulty: "Expert"
    };
    // Set up config listeners.
    {
        document.querySelectorAll("[name=secondary_chording]").forEach((el) => {
            el.addEventListener("click", function (e) {
                const opts = document.querySelectorAll("[name=secondary_chording]");
                for (let i = 0; i < opts.length; i++) {
                    if (opts[i].checked) {
                        config.secondary_chording = opts[i].value;
                    }
                }
            });
        });
        document.querySelectorAll("[name=difficulty]").forEach((el) => {
            el.addEventListener("change", (e) => {
                config.difficulty = e.target.value;
                if (game) {
                    game.reset();
                }
            })
        })
        document.querySelector("#config_open").addEventListener("click", function (e) {
            e.preventDefault();
            document.querySelector("#config").style.display = "block";
            return false;
        });
        document.querySelector("#config_close").addEventListener("click", function (e) {
            e.preventDefault();
            document.querySelector("#config").style.display = "none";
            return false;
        });
    }

    // gMouse is the global mouse object.
    const gMouse = {
        buttons: 0,
        offsetX: 0,
        offsetY: 0,
        primaryPressed: false, // set to false after processing.
        secondaryPressed: false, // set to false after processing.
        primaryReleased: false, // set to false after processing.
        secondaryReleased: false, // ste to false after processing.
    };
    // Set up mouse events.
    {
        document.addEventListener("mousemove", function (e) {
            gMouse.offsetX = e.offsetX;
            gMouse.offsetY = e.offsetY;
            gMouse.buttons = e.buttons;
        });

        document.addEventListener("mousedown", function (e) {
            gMouse.buttons = e.buttons;
            gMouse.primaryPressed = (gMouse.buttons & 1) > 0;
            gMouse.secondaryPressed = (gMouse.buttons & 2) > 0;
        });

        document.addEventListener("mouseup", function (e) {
            gMouse.primaryReleased = (gMouse.buttons & 1) > 0;
            gMouse.secondaryReleased = (gMouse.buttons & 2) > 0;
            gMouse.buttons = e.buttons;
        });

        document.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            return false;
        });

    }


    // Begin game logic. Uses grid. Uses sprite_map.

    const kGridTop = 55;
    const kGridLeft = 12;
    const kCellSize = 16;
    const game_make = function (mouse) {
        const obj = {
            time_started: null,
            time_stopped: null,
            flags_placed: 0
        };
        const cnv = document.querySelector("canvas");
        const ctx = cnv.getContext("2d");
        const grid_top = 55;
        const grid_left = 12;
        let grid;

        const kMouseStateNone = 0;
        const kMouseStateWillCord = 1; // When both mouse buttons have been pressed, and neither has been released.
        const kMouseStateWillReveal = 2; // When only the primary mouse button has been pressed.
        let mouseState = kMouseStateNone;
        let losing_mines = [];
        let won = false;
        const smiley = {
            x: 0, // set in reset.
            y: 16,
            width: 24,
            height: 24
        };
        let mines_placed;
        let mine_count;
        let difficulty = "Beginner";
        let clock_x = 0;
        const doing_small_test = false;
        let last_mouse_state;

        obj.has_won = function () {
            return won;
        }

        obj.has_lost = function () {
            return losing_mines.length > 0;
        }

        obj.has_placed_mines = function () {
            return mines_placed;
        }

        obj.get_mouse_state = function () {
            return mouseState;
        }

        obj.get_trace = function () {
            return trace;
        }

        obj.get_grid_json = function () {
            return grid_to_json(grid);
        }

        // opts may contain 'difficulty' to determine board size.
        // opts may contain 'grid' to override the grid.
        function reset(opts) {
            difficulty = config.difficulty;

            if (opts && "difficulty" in opts) {
                difficulty = opts.difficulty;
            }

            if (doing_small_test) {
                difficulty = "Test";
            }

            if (difficulty == "Test") {
                // Test with 3 mines placed deterministically on a 4x3 board.
                grid = grid_make(4, 3);
                grid[0][0].is_mine = true;
                grid[1][1].is_mine = true;
                grid[2][2].is_mine = true;
                mine_count = 3;
                mines_placed = true;
                cnv.style.backgroundImage = "url('minesweeper-expert.png')";
                cnv.setAttribute("width", "504");
                cnv.setAttribute("height", "323");
                smiley.x = 240;
                clock_x = 446;
            }
            else if (difficulty == "Expert") {
                grid = grid_make(16, 30);
                mine_count = 99;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-expert.png')";
                cnv.setAttribute("width", "504");
                cnv.setAttribute("height", "323");
                smiley.x = 240;
                clock_x = 446;
            } else if (difficulty == "Intermediate") {
                grid = grid_make(16, 16);
                mine_count = 40;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-intermediate.png')";
                cnv.setAttribute("width", "280");
                cnv.setAttribute("height", "323");
                smiley.x = 128;
                clock_x = 222;
            } else if (difficulty == "Beginner") {
                grid = grid_make(8, 8);
                mine_count = 10;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-beginner.png')";
                cnv.setAttribute("width", "152");
                cnv.setAttribute("height", "195");
                smiley.x = 64;
                clock_x = 93;
            } else {
                console.error("Unexpected difficulty: " + difficulty);
            }
            document.querySelector("#container").style.width = cnv.getAttribute("width") + "px";
            mouseState = kMouseStateNone;
            losing_mines = [];
            won = false;
            obj.flags_placed = 0;
            obj.time_started = null; // Unset.
            obj.time_stopped = null; // Unset.

            trace = [];
            enable_tracing = false;
            if (opts && 'enable_tracing' in opts && opts.enable_tracing) {
                enable_tracing = opts.enable_tracing;
            }

            if (opts && 'grid' in opts) {
                // Set fixed grid for testing.
                grid = opts.grid;
                // Assume test grid already has mines placed.
                mines_placed = true;
            }
        }

        obj.start = function (opts) {
            reset(opts);
            window.requestAnimationFrame(loop);
        }

        obj.reset = function (opts) {
            reset(opts);
        }

        // get_cell_coords returns the coordinates of a cell from a mouse position
        function get_cell_coords(mouse_x, mouse_y) {
            mouse_y -= grid_top;
            mouse_x -= grid_left;
            const i = Math.floor(mouse_y / 16);
            const j = Math.floor(mouse_x / 16);
            if (i < 0 || i >= grid.length) {
                return null;
            }
            if (j < 0 || j >= grid[0].length) {
                return null;
            }
            return { i: i, j: j };
        }

        function is_over_smiley() {
            if (mouse.offsetX >= smiley.x && mouse.offsetX <= smiley.x + smiley.width) {
                if (mouse.offsetY >= smiley.y && mouse.offsetY <= smiley.y + smiley.height) {
                    return true;
                }
            }
            return false;
        }

        obj.tick = function () {
            const mouse_coords = get_cell_coords(mouse.offsetX, mouse.offsetY);
            const mouse_cell = mouse_coords ? grid[mouse_coords.i][mouse_coords.j] : null;
            const cord_cells = [];
            if (mouse_coords) {
                for (let ip = mouse_coords.i - 1; ip <= mouse_coords.i + 1; ip++) {
                    for (let jp = mouse_coords.j - 1; jp <= mouse_coords.j + 1; jp++) {
                        if (ip >= 0 && ip < grid.length && jp >= 0 && jp < grid[ip].length) {
                            cord_cells.push(grid[ip][jp]);
                        }
                    }
                }
            }

            // Handle events.
            if (mouse.primaryPressed && mouse.secondaryPressed) {
                mouseState = kMouseStateWillCord;
            }
            else if (mouse.primaryPressed) {
                if (mouse.buttons & 2) {
                    mouseState = kMouseStateWillCord;
                } else {
                    mouseState = kMouseStateWillReveal;
                }
            }
            else if (mouse.secondaryPressed) {
                if (mouse.buttons & 1) {
                    mouseState = kMouseStateWillCord;
                } else {
                    // Toggle flag.
                    if (mouse_cell && !won && losing_mines.length == 0) {
                        if (mouse_cell.state == kCellStateFlagged) {
                            mouse_cell.state = kCellStateUnopened;
                            obj.flags_placed--;
                        } else if (mouse_cell.state == kCellStateUnopened) {
                            mouse_cell.state = kCellStateFlagged;
                            obj.flags_placed++;
                        } else if (mouse_cell.state == kCellStateOpened) {
                            if (config.secondary_chording == "only_secondary") {
                                mouseState = kMouseStateWillCord;
                            }
                        }
                    }
                }
            }

            if (mouse.primaryReleased) {
                if (mouseState == kMouseStateWillCord) {
                    if (mouse_cell) {
                        let res = cell_chord(mouse_cell);
                        if (!res.ok) {
                            losing_mines = res.losing_mines;
                            obj.time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            obj.time_stopped = Date.now();
                            // Flag any unflagged mines so the remaining mine count is correct.
                            for (let i = 0; i < grid.length; i++) {
                                for (let j = 0; j < grid[i].length; j++) {
                                    if (grid[i][j].is_mine && grid[i][j].state == kCellStateUnopened) {
                                        obj.flags_placed++;
                                        grid[i][j].state = kCellStateFlagged;
                                    }
                                }
                            }
                        }
                    }
                    mouseState = kMouseStateNone;
                }
                else if (mouseState == kMouseStateWillReveal) {
                    if (mouse_cell) {
                        if (!mines_placed) {
                            grid_set_mines(grid, mouse_coords.i, mouse_coords.j, mine_count);
                            mines_placed = true;
                        }
                        if (!obj.time_started && mouse_cell.state == kCellStateUnopened) {
                            obj.time_started = Date.now();
                        }
                        let ok = cell_reveal(mouse_cell);
                        if (!ok) {
                            losing_mines = [mouse_cell];
                            obj.time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            obj.time_stopped = Date.now();
                            // Flag any unflagged mines so the remaining mine count is correct.
                            for (let i = 0; i < grid.length; i++) {
                                for (let j = 0; j < grid[i].length; j++) {
                                    if (grid[i][j].is_mine && grid[i][j].state == kCellStateUnopened) {
                                        obj.flags_placed++;
                                        grid[i][j].state = kCellStateFlagged;
                                    }
                                }
                            }
                        }
                    }
                    mouseState = kMouseStateNone;
                }
            }

            if (mouse.secondaryReleased) {
                if (mouseState == kMouseStateWillCord) {
                    if (mouse_cell) {
                        let res = cell_chord(mouse_cell);
                        if (!res.ok) {
                            losing_mines = res.losing_mines;
                            obj.time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            obj.time_stopped = Date.now();
                        }
                    }
                    mouseState = kMouseStateNone;
                }
            }

            // If neither button was released, and no buttons are pressed, reset state.
            // This can happen if the user switches tabs and switches back.
            if ((!mouse.primaryReleased && !mouse.secondaryReleased) && mouse.buttons === 0) {
                mouseState = kMouseStateNone;
            }

            // If lost or won, do not handle more mouse states on cell.
            if (losing_mines.length > 0 || won) {
                mouseState = kMouseStateNone;
            }

            // Check if smiley pressed.
            let smileyPressed = false;
            if ((mouse.buttons & 1) && is_over_smiley()) {
                smileyPressed = true;
                // Match Minesweeper-X: When smiley is pressed, do not enter reveal / chord state.
                mouseState = kMouseStateNone;
            }
            if (mouse.primaryReleased && is_over_smiley()) {
                reset();
            }

            mouse.primaryReleased = false;
            mouse.secondaryReleased = false;
            mouse.primaryPressed = false;
            mouse.secondaryPressed = false;

            function in_cell_list(cell_list, cell) {
                for (let i = 0; i < cell_list.length; i++) {
                    if (cell_list[i] == cell) {
                        return true;
                    }
                }
                return false;
            }

            // Render grid.
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    const cell = grid[i][j];
                    let sprite = null;
                    if (cell.state == kCellStateOpened) {
                        // Draw rendered cell.
                        if (cell.is_mine) {
                            sprite = sprite_map["mine"];
                        } else {
                            const cnt = cell_mine_count(cell)
                            if (cnt == 0) {
                                sprite = sprite_map["cell_pressed"];
                            } else {
                                sprite = sprite_map["" + cnt];
                            }
                        }
                    } else if (cell.state == kCellStateUnopened) {
                        let in_cord_cells = in_cell_list(cord_cells, cell);
                        if (mouseState == kMouseStateWillReveal && mouse_cell && mouse_cell == cell) {
                            sprite = sprite_map["cell_pressed"];
                        } else if (mouseState == kMouseStateWillCord && in_cord_cells) {
                            sprite = sprite_map["cell_pressed"];
                        } else {
                            sprite = sprite_map["cell"];
                        }
                    } else if (cell.state == kCellStateFlagged) {
                        sprite = sprite_map["flag"];
                    }

                    if (losing_mines.length > 0) {
                        if (cell.is_mine) {
                            if (in_cell_list(losing_mines, cell)) {
                                sprite = sprite_map["mine_red"];
                            } else {
                                sprite = sprite_map["mine"];
                            }
                        }
                        if (cell.state == kCellStateFlagged && !cell.is_mine) {
                            sprite = sprite_map["mine_x"];
                        }
                    }

                    ctx.drawImage(sprite, grid_left + 16 * j, grid_top + 16 * i);
                }
            }

            // Render smiley.
            {
                let smileySprite = sprite_map["smiley"];
                if (smileyPressed) {
                    smileySprite = sprite_map["smiley_pressed"];
                } else if (mouseState == kMouseStateWillCord || mouseState == kMouseStateWillReveal) {
                    smileySprite = sprite_map["smiley_o"];
                }
                else if (losing_mines.length > 0) {
                    smileySprite = sprite_map["smiley_dead"];
                }
                else if (won) {
                    smileySprite = sprite_map["smiley_glasses"];
                }
                ctx.drawImage(smileySprite, smiley.x, smiley.y);
            }

            // Render remaining mines count.
            {
                let remaining_mines = mine_count - obj.flags_placed;
                remaining_mines %= 1000; // Only display three digits.
                let digits = ["d0", "d0", "d0"];
                if (remaining_mines < 0) {
                    digits[0] = "ddash";
                    remaining_mines *= -1;
                    remaining_mines %= 100; // Only display 2 digits.
                }
                if (remaining_mines > 0) {
                    digits[2] = "d" + (remaining_mines % 10);
                    remaining_mines = Math.floor(remaining_mines / 10);
                }
                if (remaining_mines > 0) {
                    digits[1] = "d" + (remaining_mines % 10);
                    remaining_mines = Math.floor(remaining_mines / 10);
                }
                if (digits[0] != "ddash" && remaining_mines > 0) {
                    digits[0] = "d" + (remaining_mines % 10);
                }
                for (let i = 0; i < digits.length; i++) {
                    ctx.drawImage(sprite_map[digits[i]], 17 + i * 13, 16);
                }
            }

            // Render clock.
            {
                let seconds = 0;
                if (obj.time_started) {
                    let diff_ms;
                    if (obj.time_stopped) {
                        diff_ms = obj.time_stopped - obj.time_started;
                    } else {
                        diff_ms = Date.now() - obj.time_started;
                    }
                    seconds = Math.floor(diff_ms / 1000);
                }
                if (seconds > 999) {
                    seconds = 999;
                }

                let digits = ["d0", "d0", "d0"];
                if (seconds > 0) {
                    digits[2] = "d" + (seconds % 10);
                    seconds = Math.floor(seconds / 10);
                }
                if (seconds > 0) {
                    digits[1] = "d" + (seconds % 10);
                    seconds = Math.floor(seconds / 10);
                }
                if (seconds[0] != "ddash" && seconds > 0) {
                    digits[0] = "d" + (seconds % 10);
                }
                for (let i = 0; i < digits.length; i++) {
                    ctx.drawImage(sprite_map[digits[i]], clock_x + i * 13, 16);
                }
            }
        }

        function loop() {
            obj.tick();
            window.requestAnimationFrame(loop);
        }

        function test_get_cell() {
            grid = grid_make(2, 2);
            function eq(a, b) {
                if ((a === null) && (b === null)) return true;
                if ((a === null) != (b === null)) return false;
                return a.i == b.i && a.j == b.j;
            }
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 15), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 16), { i: 1, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 15, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 32, grid_top + 0), null));
        }
        obj.selftest = function () {
            test_get_cell();
        }

        return obj;
    }

    // Test game.
    {
        function test_fixture_make() {
            let t = {};

            t.mouse = {
                buttons: 0,
                offsetX: 0,
                offsetY: 0,
                primaryPressed: false, // set to false after processing.
                secondaryPressed: false, // set to false after processing.
                primaryReleased: false, // set to false after processing.
                secondaryReleased: false, // ste to false after processing.
            };

            // Make a sample grid.
            t.grid = grid_make(4, 3);
            t.grid[0][0].is_mine = true;
            t.grid[1][1].is_mine = true;
            t.grid[2][2].is_mine = true;

            t.mouse_move = function (i, j) {
                t.mouse.offsetX = kGridLeft + (j * kCellSize);
                t.mouse.offsetY = kGridTop + (i * kCellSize);
            }

            t.mouse_pressSecondary = function () {
                t.mouse.buttons |= 2;
                t.mouse.secondaryPressed = true;
            }

            t.mouse_releaseSecondary = function () {
                t.mouse.buttons &= ~2;
                t.mouse.secondaryReleased = true;
            }

            t.mouse_pressPrimary = function () {
                t.mouse.buttons |= 1;
                t.mouse.primaryPressed = true;
            }

            t.mouse_releasePrimary = function () {
                t.mouse.buttons &= ~1;
                t.mouse.primaryReleased = true;
            }

            t.reveal = function (g, i, j) {
                t.mouse_move(i, j);
                t.mouse_pressPrimary();
                g.tick();
                t.mouse_releasePrimary();
                g.tick();
            }

            t.flag = function (g, i, j) {
                t.mouse_move(i, j);
                t.mouse_pressSecondary();
                g.tick();
                t.mouse_releaseSecondary();
                g.tick();
            }

            t.reveal_all = function (g, grid) {
                for (let i = 0; i < grid.length; i++) {
                    for (let j = 0; j < grid[i].length; j++) {
                        if (!grid[i][j].is_mine) {
                            t.reveal(g, i, j);
                        }
                    }
                }
            }

            t.chord = function (g, i, j) {
                t.mouse_move(i, j);
                t.mouse_pressSecondary();
                g.tick();
                t.mouse_releaseSecondary();
                g.tick();
            }
            return t;
        }

        function test_timer() {
            // Setting a flag does not start the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.mouse_move(0, 1);
                t.mouse_pressSecondary();
                g.tick();
                console.assert(!g.time_started);
            }
            // Revealing starts the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.mouse_move(0, 1);
                t.mouse_pressPrimary();
                g.tick();
                t.mouse_releasePrimary();
                g.tick();
                console.assert(g.time_started);
            }
            // Clicking off grid does not start the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.mouse_move(0, -1);
                t.mouse_pressPrimary();
                g.tick();
                t.mouse_releasePrimary();
                g.tick();
                console.assert(!g.time_started);
            }
            // Winning stops the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                console.assert(!g.time_stopped);
                t.reveal_all(g, t.grid);
                console.assert(g.time_stopped);
            }
            // Winning by chording stops the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                console.assert(!g.time_stopped);
                t.flag(g, 0, 0);
                t.flag(g, 1, 1);
                t.flag(g, 2, 2);
                t.reveal(g, 0, 1);
                t.chord(g, 0, 1);
                t.chord(g, 1, 0);
                t.chord(g, 2, 1);
                console.assert(g.time_stopped);
            }
            // Losing stops the timer.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                console.assert(!g.time_stopped);
                t.reveal(g, 0, 0);
                g.tick();
                console.assert(g.time_stopped);
            }
        }

        function test_flags_placed() {
            // flags_placed is incremented on flag placement.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                console.assert(g.flags_placed == 0);
                t.flag(g, 0, 0);
                console.assert(g.flags_placed == 1);
            }
            // flags_placed is set to 0 on reset.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                console.assert(g.flags_placed == 0);
                t.flag(g, 0, 0);
                console.assert(g.flags_placed == 1);
                g.reset();
                console.assert(g.flags_placed == 0);
            }
        }

        function test_has_won() {
            // Revealing all non mine cells results in win.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.reveal_all(g, t.grid);
                console.assert(g.has_won());
            }
        }

        function test_has_lost() {
            // Revealing a mine results in loss.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.reveal(g, 0, 0);
                console.assert(g.has_lost());
            }
            // Chording a cell with incorrect flagged mines results in a loss.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.reveal(g, 0, 1);
                t.flag(g, 0, 2);
                t.flag(g, 1, 2);
                console.assert(!g.has_lost());
                t.chord(g, 0, 1);
                console.assert(g.has_lost());
            }
        }

        function test_has_placed_mines() {
            // Mines are placed on first reveal.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset();
                console.assert(!g.has_placed_mines());
                t.reveal(g, 0, 0);
                console.assert(g.has_placed_mines());
            }
            // Mines are not placed on first flag.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset();
                console.assert(!g.has_placed_mines());
                t.flag(g, 0, 0);
                console.assert(!g.has_placed_mines());
            }
            // Mines are not placed after reset.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset();
                console.assert(!g.has_placed_mines());
                t.reveal(g, 0, 0);
                console.assert(g.has_placed_mines());
                g.reset();
                console.assert(!g.has_placed_mines());
            }
        }

        function test_get_mouse_state() {
            // Primary reveals.
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);
                g.reset({ grid: t.grid });
                t.mouse_move(0, 1);
                t.mouse_pressPrimary();
                g.tick();
                t.mouse_releasePrimary();
                g.tick();
                assert_states(t.grid, [
                    "uou",
                    "uuu",
                    "uuu",
                    "uuu"
                ]);
            }
        }

        function test_get_grid_json() {
            {
                const t = test_fixture_make();
                const g = game_make(t.mouse);

                g.reset({ grid: t.grid, enable_tracing: true });
                t.reveal(g, 0, 1);
                const grid_json = g.get_grid_json();
                console.assert(grid_json[0][1].state == kCellStateOpened);
            }
        }

        function test_game() {
            test_timer();
            test_flags_placed();
            test_has_won();
            test_has_lost();
            test_has_placed_mines();
            test_get_mouse_state();
            test_get_grid_json();
        }
    }

    let game = null;

    // Begin loading sprite map.
    const sprite_map = {};
    (function () {
        const image = new Image();
        // Wait for the sprite sheet to load
        image.onload = () => {
            const ps = [];
            // Cut two rows of 16x16 squares.
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 8; j++) {
                    ps.push(createImageBitmap(image, 17 * j, 49 + 17 * i, 16, 16));
                }
            }
            // Cut row of smileys.
            for (let i = 0; i < 5; i++) {
                ps.push(createImageBitmap(image, 25 * i, 24, 24, 24));
            }
            // Cut row of digits.
            for (let i = 0; i < 12; i++) {
                ps.push(createImageBitmap(image, 14 * i, 0, 13, 23));
            }
            Promise.all(ps).then((sprites) => {
                const sprite_names = [
                    "cell", "cell_pressed", "flag", "question", "question_pressed", "mine", "mine_red", "mine_x", "1", "2", "3", "4", "5", "6", "7", "8", "smiley", "smiley_pressed", "smiley_o", "smiley_glasses", "smiley_dead", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d0", "ddash", "dempty"
                ];
                // Draw each sprite onto the canvas
                console.assert(sprite_names.length == sprites.length);
                for (let i = 0; i < sprite_names.length; i++) {
                    sprite_map[sprite_names[i]] = sprites[i];
                }
                test_game();
                game = game_make(gMouse);
                game.start({ enable_tracing: true });
            });

        };

        image.onerror = () => {
            console.error("Failed to load spritesheet image");
        }

        // Load the sprite sheet from an image file
        image.src = "spritesheet.png";
    }());

    // Begin grid logic. Does not interact with UI.
    const kCellStateUnopened = 0;
    const kCellStateOpened = 1;
    const kCellStateFlagged = 2;

    // grid_make makes a grid with no mines.
    function grid_make(n_rows, n_cols) {
        const grid = [];
        for (let i = 0; i < n_rows; i++) {
            const row = [];
            for (let j = 0; j < n_cols; j++) {
                const cell = {
                    state: kCellStateUnopened,
                    is_mine: false
                };
                row.push(cell);
            }
            grid.push(row)
        }
        // Loop again, and make links to neighbors.
        for (let i = 0; i < n_rows; i++) {
            for (let j = 0; j < n_cols; j++) {
                const cell = grid[i][j];
                grid[i][j].nw = i > 0 && j > 0 ? grid[i - 1][j - 1] : null;
                grid[i][j].n = i > 0 ? grid[i - 1][j] : null;
                grid[i][j].ne = i > 0 && j < n_cols - 1 ? grid[i - 1][j + 1] : null;

                grid[i][j].w = j > 0 ? grid[i][j - 1] : null;
                grid[i][j].e = j < n_cols - 1 ? grid[i][j + 1] : null;

                grid[i][j].sw = i < n_rows - 1 && j > 0 ? grid[i + 1][j - 1] : null;
                grid[i][j].s = i < n_rows - 1 ? grid[i + 1][j] : null;
                grid[i][j].se = i < n_rows - 1 && j < n_cols - 1 ? grid[i + 1][j + 1] : null;
            }
        }
        return grid;
    };

    function shuffle(arr) {
        for (let i = 0; i < arr.length; i++) {
            let dst = Math.floor(Math.random() * arr.length);
            let tmp = arr[dst];
            arr[dst] = arr[i];
            arr[i] = tmp;
        }
    }

    // grid_set_mines adds num_mines randomly. start_i and start_j are excluded from consideration.
    function grid_set_mines(grid, start_i, start_j, num_mines) {
        const num_rows = grid.length;
        const num_cols = grid[0].length;

        console.assert(num_mines <= num_rows * num_cols - 1);
        let positions = [];
        for (let i = 0; i < num_rows; i++) {
            for (let j = 0; j < num_cols; j++) {
                if (i == start_i && j == start_j) {
                    continue;
                }
                positions.push({ i: i, j: j });
            }
        }
        shuffle(positions);
        for (let m = 0; m < num_mines; m++) {
            grid[positions[m].i][positions[m].j].is_mine = true;
        }
    }

    // grid_to_json returns a JSON friendly grid
    function grid_to_json(grid) {
        const num_rows = grid.length;
        const num_cols = grid[0].length;

        let grid_json = [];
        for (let i = 0; i < grid.length; i++) {
            let grid_json_row = [];
            for (let j = 0; j < grid[i].length; j++) {
                let grid_json_cell = {
                    state: grid[i][j].state,
                    is_mine: grid[i][j].is_mine
                };
                grid_json_row.push(grid_json_cell);
            }
            grid_json.push(grid_json_row);
        }
        return grid_json;
    }

    const kGridStateInProgress = 0;
    const kGridStateWon = 1;
    const kGridStateLost = 2;
    function grid_state(grid) {
        let num_mines = 0;
        let num_open = 0;
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                let cell = grid[i][j];
                if (cell.state == kCellStateOpened && cell.is_mine) {
                    return kGridStateLost;
                }
                if (cell.state == kCellStateOpened) {
                    num_open++;
                }
                if (cell.is_mine) {
                    num_mines++;
                }
            }
        }
        let num_cells = grid.length * grid[0].length;
        return num_cells - num_open == num_mines;
    }

    function cell_mine_count(cell) {
        console.assert(!cell.is_mine);
        let count = 0;
        if (cell.ne && cell.ne.is_mine) count++;
        if (cell.n && cell.n.is_mine) count++;
        if (cell.nw && cell.nw.is_mine) count++;
        if (cell.w && cell.w.is_mine) count++;
        if (cell.e && cell.e.is_mine) count++;
        if (cell.se && cell.se.is_mine) count++;
        if (cell.s && cell.s.is_mine) count++;
        if (cell.sw && cell.sw.is_mine) count++;
        return count;
    }

    function cell_flag_count(cell) {
        let count = 0;
        if (cell.ne && cell.ne.state == kCellStateFlagged) count++;
        if (cell.n && cell.n.state == kCellStateFlagged) count++;
        if (cell.nw && cell.nw.state == kCellStateFlagged) count++;
        if (cell.w && cell.w.state == kCellStateFlagged) count++;
        if (cell.e && cell.e.state == kCellStateFlagged) count++;
        if (cell.se && cell.se.state == kCellStateFlagged) count++;
        if (cell.s && cell.s.state == kCellStateFlagged) count++;
        if (cell.sw && cell.sw.state == kCellStateFlagged) count++;
        return count;
    }

    // cell_reveal returns false if cell is a is_mine.
    function cell_reveal(cell) {
        if (cell.state == kCellStateOpened) {
            // Already revealed. Do nothing.
            return true;
        }
        if (cell.state == kCellStateFlagged) {
            // Flagged cells cannot be revealed without unflagging. Do nothing.
            return true;
        }

        cell.state = kCellStateOpened;
        if (cell.is_mine) {
            return false;
        }

        // If no neighbors are mines, reveal all neighbors.
        if (cell_mine_count(cell) != 0) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) cell_reveal(cell.ne);
        if (cell.n && cell.n.state == kCellStateUnopened) cell_reveal(cell.n);
        if (cell.nw && cell.nw.state == kCellStateUnopened) cell_reveal(cell.nw);
        if (cell.w && cell.w.state == kCellStateUnopened) cell_reveal(cell.w);
        if (cell.e && cell.e.state == kCellStateUnopened) cell_reveal(cell.e);
        if (cell.se && cell.se.state == kCellStateUnopened) cell_reveal(cell.se);
        if (cell.s && cell.s.state == kCellStateUnopened) cell_reveal(cell.s);
        if (cell.sw && cell.sw.state == kCellStateUnopened) cell_reveal(cell.sw);
        return true;
    }

    // cell_chord attempts to reveal cells if the number of flagged neighbors equals the number of neighboring mines.
    // returns false if a revealed cell is a is_mine.
    // does nothing if the number of flagged neighbors is not equal to the number of neighboring mines.
    function cell_chord(cell) {
        if (cell.state != kCellStateOpened) {
            // Not open. Do nothing.
            return { ok: true };
        }

        if (cell_mine_count(cell) != cell_flag_count(cell)) {
            return { ok: true };
        }

        let losing_mines = [];

        if (cell.ne && cell.ne.state == kCellStateUnopened) {
            if (!cell_reveal(cell.ne)) { losing_mines.push(cell.ne); }
        }
        if (cell.n && cell.n.state == kCellStateUnopened) {
            if (!cell_reveal(cell.n)) { losing_mines.push(cell.n); }
        }
        if (cell.nw && cell.nw.state == kCellStateUnopened) {
            if (!cell_reveal(cell.nw)) { losing_mines.push(cell.nw); }
        }
        if (cell.w && cell.w.state == kCellStateUnopened) {
            if (!cell_reveal(cell.w)) { losing_mines.push(cell.w); }
        }
        if (cell.e && cell.e.state == kCellStateUnopened) {
            if (!cell_reveal(cell.e)) { losing_mines.push(cell.e); }
        }
        if (cell.se && cell.se.state == kCellStateUnopened) {
            if (!cell_reveal(cell.se)) { losing_mines.push(cell.se); }
        }
        if (cell.s && cell.s.state == kCellStateUnopened) {
            if (!cell_reveal(cell.s)) { losing_mines.push(cell.s); }
        }
        if (cell.sw && cell.sw.state == kCellStateUnopened) {
            if (!cell_reveal(cell.sw)) { losing_mines.push(cell.sw); }
        }

        if (losing_mines.length > 0) {
            return { ok: false, losing_mines: losing_mines };
        }
        return { ok: true };
    }


    // Testing ... begin

    function test_grid_make() {
        const grid = grid_make(3, 3);
        console.assert(grid[1][1].nw == grid[0][0]);
        console.assert(grid[1][1].n == grid[0][1]);
        console.assert(grid[1][1].ne == grid[0][2]);
        console.assert(grid[1][1].w == grid[1][0]);
        console.assert(grid[1][1].e == grid[1][2]);
        console.assert(grid[1][1].sw == grid[2][0]);
        console.assert(grid[1][1].s == grid[2][1]);
        console.assert(grid[1][1].se == grid[2][2]);
    }

    function test_grid_to_json() {
        const grid = grid_make(3, 3);
        grid[0][0].state = kCellStateFlagged;
        const grid_json = grid_to_json(grid);
        console.assert(grid.length == grid_json.length);
        for (let i = 0; i < grid.length; i++) {
            console.assert(grid[i].length == grid_json[i].length);
            for (let j = 0; j < grid[i].length; j++) {
                console.assert(grid[i][j].state == grid_json[i][j].state);
                console.assert(grid[i][j].is_mine == grid_json[i][j].is_mine);
            }
        }
    }

    // ch2state maps a character to a cell state.
    const ch2state = {
        "u": kCellStateUnopened,
        "o": kCellStateOpened,
        "f": kCellStateFlagged
    };

    // state2ch maps a cell state to a character.
    let state2ch = {};
    for (k in ch2state) {
        let v = ch2state[k];
        state2ch[v] = k;
    }

    function grid2str(grid) {
        let ret = "";
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                ret += state2ch[grid[i][j].state];
            }
            ret += "\n";
        }
        return ret;
    }

    function assert_states(grid, expected_states) {
        console.assert(grid.length == expected_states.length, "Expected expected_states.length == %d. Bad test input?", grid.length);
        for (let i = 0; i < grid.length; i++) {
            console.assert(grid[i].length == expected_states[i].length, "Expected expected_states[%d].length == %d. Bad test input?", i, grid[i].length);
            for (let j = 0; j < grid[i].length; j++) {
                let expected_state_ch = expected_states[i][j];
                console.assert(expected_state_ch in ch2state, "Expected state %s to be in %o", expected_state_ch, Object.keys(ch2state));
                let expected_state = ch2state[expected_state_ch];
                console.assert(grid[i][j].state == expected_state, "Expected (%d, %d) to be state %s, got %s\nExpected Grid\n%s\nGot Grid:\n%s\n", i, j, expected_state_ch, state2ch[grid[i][j].state], expected_states.join("\n"), grid2str(grid));
            }
        }
    }

    function test_reveal() {
        // Reveal returns false on a mine, true on non-mine.
        {
            const grid = grid_make(3, 3);
            grid[0][0].is_mine = true;
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(cell_reveal(grid[1][0]));
        }
        // Reveal recursively reveals.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            assert_states(grid, [
                "uu",
                "uu",
                "uu"
            ]);
            console.assert(cell_reveal(grid[2][1]));
            assert_states(grid, [
                "uu",
                "oo",
                "oo"
            ]);
        }
    }

    function test_chord() {
        // Chord does nothing if no flagged neighbors.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
            // Attempting to chord does nothing.
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
        }
        // Chord reveals if number of flagged neighbors is equal to number of mines.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "uu",
                "uu"
            ]);
            // After flagging the mine, chording reveals.
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "oo",
                "uu"
            ]);
            // Chord works again.
            console.assert(cell_chord(grid[1][1]).ok);
            assert_states(grid, [
                "fo",
                "oo",
                "oo"
            ]);
        }

        // Chord returns false if a mine is revealed.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "uo",
                "fu",
                "uu"
            ]);
            // After flagging the incorrect mine, chording reveals and returns false.
            console.assert(!cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "oo",
                "fo",
                "uu"
            ]);
        }

        // Chord does not reveal neighbors if number of flagged neighbors is greater than number of mines.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not recursively chord.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            grid[1][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "fo",
                "uu"
            ]);
        }
    }

    function test_grid_state() {
        // Grid is won once all non-mine cells are revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(cell_reveal(grid[0][1]));
            console.assert(cell_reveal(grid[1][0]));
            console.assert(cell_reveal(grid[1][1]));
            console.assert(grid_state(grid) == kGridStateWon);
        }
        // Grid is lost once a mine cells is revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(grid_state(grid) == kGridStateLost);
        }
    }

    function test_grid_set_mines() {
        // Mines are not set on starting position.
        {
            const grid = grid_make(2, 2);
            grid_set_mines(grid, 0, 0, 3);
            console.assert(!grid[0][0].is_mine);
            console.assert(grid[1][0].is_mine);
            console.assert(grid[0][1].is_mine);
            console.assert(grid[1][1].is_mine);
        }
    }


    function run_tests() {
        test_grid_make();
        test_reveal();
        test_chord();
        test_grid_state();
        test_grid_set_mines();
        test_grid_to_json();
        let g = game_make();
        g.selftest();
    }

    run_tests();

    // Testing ... end
</script>

</html>