<html>

<head>
    <style type="text/css">
        canvas {
            border: 1px black solid;
        }

        #config {
            position: fixed;
            left: 10%;
            top: 10%;
            width: 76%;
            background: white;
            border: 1px black solid;
            padding: 1%;
            display: none;
        }
    </style>
</head>

<body>
    <div id="config">
        <a href="#" id="config_close">Close</a>
        <p>Use secondary mouse click for chording?</p>
        <input type="radio" name="secondary_chording" value="only_secondary" checked="checked"><label>Only secondary
            (convenient for track pads)</label>
        <input type="radio" name="secondary_chording" value="both"><label>Both primary and secondary
            (traditional)</label>
        <p>Difficulty</p>
        <input type="radio" name="difficulty" value="Beginner" id="difficulty_Beginner"><label
            for="difficulty_Beginner">Beginner</label>
        <input type="radio" name="difficulty" value="Intermediate" id="difficulty_Intermediate"><label
            for="difficulty_Intermediate">Intermediate</label>
        <input type="radio" name="difficulty" value="Expert" id="difficulty_Expert" checked="checked"><label
            for="difficulty_Expert">Expert</label>
    </div>
    <canvas width="504" height="323"></canvas>
    <p><a href="#" id="config_open">Settings</a></p>
</body>
<script>
    const config = {
        secondary_chording: "only_secondary",
        difficulty: "Expert"
    };
    // Set up config listeners.
    {
        document.querySelectorAll("[name=secondary_chording]").forEach((el) => {
            el.addEventListener("click", function (e) {
                const opts = document.querySelectorAll("[name=secondary_chording]");
                for (let i = 0; i < opts.length; i++) {
                    if (opts[i].checked) {
                        config.secondary_chording = opts[i].value;
                    }
                }
            });
        });
        document.querySelectorAll("[name=difficulty]").forEach((el) => {
            el.addEventListener("change", (e) => {
                config.difficulty = e.target.value;
                if (game) {
                    game.reset();
                }
            })
        })
        document.querySelector("#config_open").addEventListener("click", function (e) {
            e.preventDefault();
            document.querySelector("#config").style.display = "block";
            return false;
        });
        document.querySelector("#config_close").addEventListener("click", function (e) {
            e.preventDefault();
            document.querySelector("#config").style.display = "none";
            return false;
        });
    }

    const mouse = {
        buttons: 0,
        offsetX: 0,
        offsetY: 0,
        primaryPressed: false, // set to false after processing.
        secondaryPressed: false, // set to false after processing.
        primaryReleased: false, // set to false after processing.
        secondaryReleased: false, // ste to false after processing.
    };
    // Set up mouse events.
    {
        document.addEventListener("mousemove", function (e) {
            mouse.offsetX = e.offsetX;
            mouse.offsetY = e.offsetY;
            mouse.buttons = e.buttons;
        });

        document.addEventListener("mousedown", function (e) {
            mouse.buttons = e.buttons;
            mouse.primaryPressed = (mouse.buttons & 1) > 0;
            mouse.secondaryPressed = (mouse.buttons & 2) > 0;
        });

        document.addEventListener("mouseup", function (e) {
            mouse.primaryReleased = (mouse.buttons & 1) > 0;
            mouse.secondaryReleased = (mouse.buttons & 2) > 0;
            mouse.buttons = e.buttons;
        });

        document.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            return false;
        });

    }


    // Begin game logic. Uses grid. Uses sprite_map.
    const game_make = function () {
        const obj = {};
        const cnv = document.querySelector("canvas");
        const ctx = cnv.getContext("2d");
        const grid_top = 55;
        const grid_left = 12;
        let grid;

        const kMouseStateNone = 0;
        const kMouseStateWillCord = 1; // When both mouse buttons have been pressed, and neither has been released.
        const kMouseStateWillReveal = 2; // When only the primary mouse button has been pressed.
        let mouseState = kMouseStateNone;
        let losing_mines = [];
        let won = false;
        const smiley = {
            x: 0, // set in reset.
            y: 16,
            width: 24,
            height: 24
        };
        let mines_placed;
        let mine_count;
        let difficulty = "Beginner";
        let flags_placed;
        let time_started;
        let time_stopped;
        let clock_x = 0;
        const doing_small_test = false;

        function reset() {
            let difficulty = config.difficulty;
            if (doing_small_test) {
                difficulty = "Test";
            }

            if (difficulty == "Test") {
                // Test with 3 mines placed deterministically on a 4x3 board.
                grid = grid_make(4, 3);
                grid[0][0].is_mine = true;
                grid[1][1].is_mine = true;
                grid[2][2].is_mine = true;
                mine_count = 3;
                mines_placed = true;
                cnv.style.backgroundImage = "url('minesweeper-expert.png')";
                cnv.setAttribute("width", "504");
                cnv.setAttribute("height", "323");
                smiley.x = 240;
                clock_x = 446;
            }
            else if (difficulty == "Expert") {
                grid = grid_make(16, 30);
                mine_count = 99;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-expert.png')";
                cnv.setAttribute("width", "504");
                cnv.setAttribute("height", "323");
                smiley.x = 240;
                clock_x = 446;
            } else if (difficulty == "Intermediate") {
                grid = grid_make(16, 16);
                mine_count = 40;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-intermediate.png')";
                cnv.setAttribute("width", "280");
                cnv.setAttribute("height", "323");
                smiley.x = 128;
                clock_x = 222;
            } else if (difficulty == "Beginner") {
                grid = grid_make(8, 8);
                mine_count = 10;
                mines_placed = false;
                cnv.style.backgroundImage = "url('minesweeper-beginner.png')";
                cnv.setAttribute("width", "152");
                cnv.setAttribute("height", "195");
                smiley.x = 64;
                clock_x = 93;
            } else {
                console.error("Unexpected difficulty: " + difficulty);
            }
            mouseState = kMouseStateNone;
            losing_mines = [];
            won = false;
            flags_placed = 0;
            time_started = null; // Unset.
            time_stopped = null; // Unset.
        }

        obj.start = function () {
            reset();
            window.requestAnimationFrame(loop);
        }

        obj.reset = function () {
            reset();
        }

        // get_cell_coords returns the coordinates of a cell from a mouse position
        function get_cell_coords(mouse_x, mouse_y) {
            mouse_y -= grid_top;
            mouse_x -= grid_left;
            const i = Math.floor(mouse_y / 16);
            const j = Math.floor(mouse_x / 16);
            if (i < 0 || i >= grid.length) {
                return null;
            }
            if (j < 0 || j >= grid[0].length) {
                return null;
            }
            return { i: i, j: j };
        }

        function is_over_smiley() {
            if (mouse.offsetX >= smiley.x && mouse.offsetX <= smiley.x + smiley.width) {
                if (mouse.offsetY >= smiley.y && mouse.offsetY <= smiley.y + smiley.height) {
                    return true;
                }
            }
            return false;
        }

        function tick() {
            const mouse_coords = get_cell_coords(mouse.offsetX, mouse.offsetY);
            const mouse_cell = mouse_coords ? grid[mouse_coords.i][mouse_coords.j] : null;
            const cord_cells = [];
            if (mouse_coords) {
                for (let ip = mouse_coords.i - 1; ip <= mouse_coords.i + 1; ip++) {
                    for (let jp = mouse_coords.j - 1; jp <= mouse_coords.j + 1; jp++) {
                        if (ip >= 0 && ip < grid.length && jp >= 0 && jp < grid[ip].length) {
                            cord_cells.push(grid[ip][jp]);
                        }
                    }
                }
            }

            // Handle events.
            if (mouse.primaryPressed && mouse.secondaryPressed) {
                mouseState = kMouseStateWillCord;
            }
            else if (mouse.primaryPressed) {
                if (mouse.buttons & 2) {
                    mouseState = kMouseStateWillCord;
                } else {
                    mouseState = kMouseStateWillReveal;
                }
            }
            else if (mouse.secondaryPressed) {
                if (mouse.buttons & 1) {
                    mouseState = kMouseStateWillCord;
                } else {
                    // Toggle flag.
                    if (mouse_cell && !won && losing_mines.length == 0) {
                        if (mouse_cell.state == kCellStateFlagged) {
                            mouse_cell.state = kCellStateUnopened;
                            flags_placed--;
                        } else if (mouse_cell.state == kCellStateUnopened) {
                            mouse_cell.state = kCellStateFlagged;
                            flags_placed++;
                        } else if (mouse_cell.state == kCellStateOpened) {
                            if (config.secondary_chording == "only_secondary") {
                                mouseState = kMouseStateWillCord;
                            }
                        }
                    }
                }
            }

            if (mouse.primaryReleased) {
                if (mouseState == kMouseStateWillCord) {
                    if (mouse_cell) {
                        let res = cell_chord(mouse_cell);
                        if (!res.ok) {
                            losing_mines = res.losing_mines;
                            time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            time_stopped = Date.now();
                            // Flag any unflagged mines so the remaining mine count is correct.
                            for (let i = 0; i < grid.length; i++) {
                                for (let j = 0; j < grid[i].length; j++) {
                                    if (grid[i][j].is_mine && grid[i][j].state == kCellStateUnopened) {
                                        flags_placed++;
                                        grid[i][j].state = kCellStateFlagged;
                                    }
                                }
                            }
                        }
                    }
                    mouseState = kMouseStateNone;
                }
                else if (mouseState == kMouseStateWillReveal) {
                    if (mouse_cell) {
                        if (!mines_placed) {
                            grid_set_mines(grid, mouse_coords.i, mouse_coords.j, mine_count);
                            mines_placed = true;
                        }
                        if (!time_started && mouse_cell.state == kCellStateUnopened) {
                            time_started = Date.now();
                        }
                        let ok = cell_reveal(mouse_cell);
                        if (!ok) {
                            losing_mines = [mouse_cell];
                            time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            time_stopped = Date.now();
                            // Flag any unflagged mines so the remaining mine count is correct.
                            for (let i = 0; i < grid.length; i++) {
                                for (let j = 0; j < grid[i].length; j++) {
                                    if (grid[i][j].is_mine && grid[i][j].state == kCellStateUnopened) {
                                        flags_placed++;
                                        grid[i][j].state = kCellStateFlagged;
                                    }
                                }
                            }
                        }
                    }
                    mouseState = kMouseStateNone;
                }
            }

            if (mouse.secondaryReleased) {
                if (mouseState == kMouseStateWillCord) {
                    if (mouse_cell) {
                        let res = cell_chord(mouse_cell);
                        if (!res.ok) {
                            losing_mines = res.losing_mines;
                            time_stopped = Date.now();
                        } else if (grid_state(grid) == kGridStateWon) {
                            won = true;
                            time_stopped = Date.now();
                        }
                    }
                    mouseState = kMouseStateNone;
                }
            }

            // If neither button was released, and no buttons are pressed, reset state.
            // This can happen if the user switches tabs and switches back.
            if ((!mouse.primaryReleased && !mouse.secondaryReleased) && mouse.buttons === 0) {
                mouseState = kMouseStateNone;
            }

            // If lost or won, do not handle more mouse states on cell.
            if (losing_mines.length > 0 || won) {
                mouseState = kMouseStateNone;
            }

            // Check if smiley pressed.
            let smileyPressed = false;
            if ((mouse.buttons & 1) && is_over_smiley()) {
                smileyPressed = true;
                // Match Minesweeper-X: When smiley is pressed, do not enter reveal / chord state.
                mouseState = kMouseStateNone;
            }
            if (mouse.primaryReleased && is_over_smiley()) {
                reset();
            }

            mouse.primaryReleased = false;
            mouse.secondaryReleased = false;
            mouse.primaryPressed = false;
            mouse.secondaryPressed = false;

            function in_cell_list(cell_list, cell) {
                for (let i = 0; i < cell_list.length; i++) {
                    if (cell_list[i] == cell) {
                        return true;
                    }
                }
                return false;
            }

            // Render grid.
            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    const cell = grid[i][j];
                    let sprite = null;
                    if (cell.state == kCellStateOpened) {
                        // Draw rendered cell.
                        if (cell.is_mine) {
                            sprite = sprite_map["mine"];
                        } else {
                            const cnt = cell_mine_count(cell)
                            if (cnt == 0) {
                                sprite = sprite_map["cell_pressed"];
                            } else {
                                sprite = sprite_map["" + cnt];
                            }
                        }
                    } else if (cell.state == kCellStateUnopened) {
                        let in_cord_cells = in_cell_list(cord_cells, cell);
                        if (mouseState == kMouseStateWillReveal && mouse_cell && mouse_cell == cell) {
                            sprite = sprite_map["cell_pressed"];
                        } else if (mouseState == kMouseStateWillCord && in_cord_cells) {
                            sprite = sprite_map["cell_pressed"];
                        } else {
                            sprite = sprite_map["cell"];
                        }
                    } else if (cell.state == kCellStateFlagged) {
                        sprite = sprite_map["flag"];
                    }

                    if (losing_mines.length > 0) {
                        if (cell.is_mine) {
                            if (in_cell_list(losing_mines, cell)) {
                                sprite = sprite_map["mine_red"];
                            } else {
                                sprite = sprite_map["mine"];
                            }
                        }
                        if (cell.state == kCellStateFlagged && !cell.is_mine) {
                            sprite = sprite_map["mine_x"];
                        }
                    }

                    ctx.drawImage(sprite, grid_left + 16 * j, grid_top + 16 * i);
                }
            }

            // Render smiley.
            {
                let smileySprite = sprite_map["smiley"];
                if (smileyPressed) {
                    smileySprite = sprite_map["smiley_pressed"];
                } else if (mouseState == kMouseStateWillCord || mouseState == kMouseStateWillReveal) {
                    smileySprite = sprite_map["smiley_o"];
                }
                else if (losing_mines.length > 0) {
                    smileySprite = sprite_map["smiley_dead"];
                }
                else if (won) {
                    smileySprite = sprite_map["smiley_glasses"];
                }
                ctx.drawImage(smileySprite, smiley.x, smiley.y);
            }

            // Render remaining mines count.
            {
                let remaining_mines = mine_count - flags_placed;
                remaining_mines %= 1000; // Only display three digits.
                let digits = ["d0", "d0", "d0"];
                if (remaining_mines < 0) {
                    digits[0] = "ddash";
                    remaining_mines *= -1;
                    remaining_mines %= 100; // Only display 2 digits.
                }
                if (remaining_mines > 0) {
                    digits[2] = "d" + (remaining_mines % 10);
                    remaining_mines = Math.floor(remaining_mines / 10);
                }
                if (remaining_mines > 0) {
                    digits[1] = "d" + (remaining_mines % 10);
                    remaining_mines = Math.floor(remaining_mines / 10);
                }
                if (digits[0] != "ddash" && remaining_mines > 0) {
                    digits[0] = "d" + (remaining_mines % 10);
                }
                for (let i = 0; i < digits.length; i++) {
                    ctx.drawImage(sprite_map[digits[i]], 17 + i * 13, 16);
                }
            }

            // Render clock.
            {
                let seconds = 0;
                if (time_started) {
                    let diff_ms;
                    if (time_stopped) {
                        diff_ms = time_stopped - time_started;
                    } else {
                        diff_ms = Date.now() - time_started;
                    }
                    seconds = Math.floor(diff_ms / 1000);
                }
                if (seconds > 999) {
                    seconds = 999;
                }

                let digits = ["d0", "d0", "d0"];
                if (seconds > 0) {
                    digits[2] = "d" + (seconds % 10);
                    seconds = Math.floor(seconds / 10);
                }
                if (seconds > 0) {
                    digits[1] = "d" + (seconds % 10);
                    seconds = Math.floor(seconds / 10);
                }
                if (seconds[0] != "ddash" && seconds > 0) {
                    seconds[0] = "d" + (seconds % 10);
                }
                for (let i = 0; i < digits.length; i++) {
                    ctx.drawImage(sprite_map[digits[i]], clock_x + i * 13, 16);
                }
            }
        }

        function loop() {
            tick();
            window.requestAnimationFrame(loop);
        }

        function test_get_cell() {
            grid = grid_make(2, 2);
            function eq(a, b) {
                if ((a === null) && (b === null)) return true;
                if ((a === null) != (b === null)) return false;
                return a.i == b.i && a.j == b.j;
            }
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 15), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 0, grid_top + 16), { i: 1, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 15, grid_top + 0), { i: 0, j: 0 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 16, grid_top + 0), { i: 0, j: 1 }));
            console.assert(eq(get_cell_coords(grid_left + 32, grid_top + 0), null));
        }
        obj.selftest = function () {
            test_get_cell();
            test_reveal();
        }

        return obj;
    }

    let game = null;

    // Begin loading sprite map.
    const sprite_map = {};
    (function () {
        const image = new Image();
        // Wait for the sprite sheet to load
        image.onload = () => {
            const ps = [];
            // Cut two rows of 16x16 squares.
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 8; j++) {
                    ps.push(createImageBitmap(image, 17 * j, 49 + 17 * i, 16, 16));
                }
            }
            // Cut row of smileys.
            for (let i = 0; i < 5; i++) {
                ps.push(createImageBitmap(image, 25 * i, 24, 24, 24));
            }
            // Cut row of digits.
            for (let i = 0; i < 12; i++) {
                ps.push(createImageBitmap(image, 14 * i, 0, 13, 23));
            }
            Promise.all(ps).then((sprites) => {
                const sprite_names = [
                    "cell", "cell_pressed", "flag", "question", "question_pressed", "mine", "mine_red", "mine_x", "1", "2", "3", "4", "5", "6", "7", "8", "smiley", "smiley_pressed", "smiley_o", "smiley_glasses", "smiley_dead", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d0", "ddash", "dempty"
                ];
                // Draw each sprite onto the canvas
                console.assert(sprite_names.length == sprites.length);
                for (let i = 0; i < sprite_names.length; i++) {
                    sprite_map[sprite_names[i]] = sprites[i];
                }
                game = game_make();
                game.start();
            });

        };

        image.onerror = () => {
            console.error("Failed to load spritesheet image");
        }

        // Load the sprite sheet from an image file
        image.src = "spritesheet.png";
    }());

    // Begin grid logic. Does not interact with UI.
    const kCellStateUnopened = 0;
    const kCellStateOpened = 1;
    const kCellStateFlagged = 2;

    // grid_make makes a grid with no mines.
    function grid_make(n_rows, n_cols) {
        const grid = [];
        for (let i = 0; i < n_rows; i++) {
            const row = [];
            for (let j = 0; j < n_cols; j++) {
                const cell = {
                    state: kCellStateUnopened,
                    is_mine: false
                };
                row.push(cell);
            }
            grid.push(row)
        }
        // Loop again, and make links to neighbors.
        for (let i = 0; i < n_rows; i++) {
            for (let j = 0; j < n_cols; j++) {
                const cell = grid[i][j];
                grid[i][j].nw = i > 0 && j > 0 ? grid[i - 1][j - 1] : null;
                grid[i][j].n = i > 0 ? grid[i - 1][j] : null;
                grid[i][j].ne = i > 0 && j < n_cols - 1 ? grid[i - 1][j + 1] : null;

                grid[i][j].w = j > 0 ? grid[i][j - 1] : null;
                grid[i][j].e = j < n_cols - 1 ? grid[i][j + 1] : null;

                grid[i][j].sw = i < n_rows - 1 && j > 0 ? grid[i + 1][j - 1] : null;
                grid[i][j].s = i < n_rows - 1 ? grid[i + 1][j] : null;
                grid[i][j].se = i < n_rows - 1 && j < n_cols - 1 ? grid[i + 1][j + 1] : null;
            }
        }
        return grid;
    };

    function shuffle(arr) {
        for (let i = 0; i < arr.length; i++) {
            let dst = Math.floor(Math.random() * arr.length);
            let tmp = arr[dst];
            arr[dst] = arr[i];
            arr[i] = tmp;
        }
    }

    // grid_set_mines adds num_mines randomly. start_i and start_j are excluded from consideration.
    function grid_set_mines(grid, start_i, start_j, num_mines) {
        const num_rows = grid.length;
        const num_cols = grid[0].length;

        console.assert(num_mines <= num_rows * num_cols - 1);
        let positions = [];
        for (let i = 0; i < num_rows; i++) {
            for (let j = 0; j < num_cols; j++) {
                if (i == start_i && j == start_j) {
                    continue;
                }
                positions.push({ i: i, j: j });
            }
        }
        shuffle(positions);
        for (let m = 0; m < num_mines; m++) {
            grid[positions[m].i][positions[m].j].is_mine = true;
        }
    }

    const kGridStateInProgress = 0;
    const kGridStateWon = 1;
    const kGridStateLost = 2;
    function grid_state(grid) {
        let num_mines = 0;
        let num_open = 0;
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                let cell = grid[i][j];
                if (cell.state == kCellStateOpened && cell.is_mine) {
                    return kGridStateLost;
                }
                if (cell.state == kCellStateOpened) {
                    num_open++;
                }
                if (cell.is_mine) {
                    num_mines++;
                }
            }
        }
        let num_cells = grid.length * grid[0].length;
        return num_cells - num_open == num_mines;
    }

    function cell_mine_count(cell) {
        console.assert(!cell.is_mine);
        let count = 0;
        if (cell.ne && cell.ne.is_mine) count++;
        if (cell.n && cell.n.is_mine) count++;
        if (cell.nw && cell.nw.is_mine) count++;
        if (cell.w && cell.w.is_mine) count++;
        if (cell.e && cell.e.is_mine) count++;
        if (cell.se && cell.se.is_mine) count++;
        if (cell.s && cell.s.is_mine) count++;
        if (cell.sw && cell.sw.is_mine) count++;
        return count;
    }

    function cell_flag_count(cell) {
        let count = 0;
        if (cell.ne && cell.ne.state == kCellStateFlagged) count++;
        if (cell.n && cell.n.state == kCellStateFlagged) count++;
        if (cell.nw && cell.nw.state == kCellStateFlagged) count++;
        if (cell.w && cell.w.state == kCellStateFlagged) count++;
        if (cell.e && cell.e.state == kCellStateFlagged) count++;
        if (cell.se && cell.se.state == kCellStateFlagged) count++;
        if (cell.s && cell.s.state == kCellStateFlagged) count++;
        if (cell.sw && cell.sw.state == kCellStateFlagged) count++;
        return count;
    }

    // cell_reveal returns false if cell is a is_mine.
    function cell_reveal(cell) {
        if (cell.state == kCellStateOpened) {
            // Already revealed. Do nothing.
            return true;
        }
        if (cell.state == kCellStateFlagged) {
            // Flagged cells cannot be revealed without unflagging. Do nothing.
            return true;
        }

        cell.state = kCellStateOpened;
        if (cell.is_mine) {
            return false;
        }

        // If no neighbors are mines, reveal all neighbors.
        if (cell_mine_count(cell) != 0) {
            return true;
        }

        if (cell.ne && cell.ne.state == kCellStateUnopened) cell_reveal(cell.ne);
        if (cell.n && cell.n.state == kCellStateUnopened) cell_reveal(cell.n);
        if (cell.nw && cell.nw.state == kCellStateUnopened) cell_reveal(cell.nw);
        if (cell.w && cell.w.state == kCellStateUnopened) cell_reveal(cell.w);
        if (cell.e && cell.e.state == kCellStateUnopened) cell_reveal(cell.e);
        if (cell.se && cell.se.state == kCellStateUnopened) cell_reveal(cell.se);
        if (cell.s && cell.s.state == kCellStateUnopened) cell_reveal(cell.s);
        if (cell.sw && cell.sw.state == kCellStateUnopened) cell_reveal(cell.sw);
        return true;
    }

    // cell_chord attempts to reveal cells if the number of flagged neighbors equals the number of neighboring mines.
    // returns false if a revealed cell is a is_mine.
    // does nothing if the number of flagged neighbors is not equal to the number of neighboring mines.
    function cell_chord(cell) {
        if (cell.state != kCellStateOpened) {
            // Not open. Do nothing.
            return { ok: true };
        }

        if (cell_mine_count(cell) != cell_flag_count(cell)) {
            return { ok: true };
        }

        let losing_mines = [];

        if (cell.ne && cell.ne.state == kCellStateUnopened) {
            if (!cell_reveal(cell.ne)) { losing_mines.push(cell.ne); }
        }
        if (cell.n && cell.n.state == kCellStateUnopened) {
            if (!cell_reveal(cell.n)) { losing_mines.push(cell.n); }
        }
        if (cell.nw && cell.nw.state == kCellStateUnopened) {
            if (!cell_reveal(cell.nw)) { losing_mines.push(cell.nw); }
        }
        if (cell.w && cell.w.state == kCellStateUnopened) {
            if (!cell_reveal(cell.w)) { losing_mines.push(cell.w); }
        }
        if (cell.e && cell.e.state == kCellStateUnopened) {
            if (!cell_reveal(cell.e)) { losing_mines.push(cell.e); }
        }
        if (cell.se && cell.se.state == kCellStateUnopened) {
            if (!cell_reveal(cell.se)) { losing_mines.push(cell.se); }
        }
        if (cell.s && cell.s.state == kCellStateUnopened) {
            if (!cell_reveal(cell.s)) { losing_mines.push(cell.s); }
        }
        if (cell.sw && cell.sw.state == kCellStateUnopened) {
            if (!cell_reveal(cell.sw)) { losing_mines.push(cell.sw); }
        }

        if (losing_mines.length > 0) {
            return { ok: false, losing_mines: losing_mines };
        }
        return { ok: true };
    }


    // Testing ... begin

    function test_grid_make() {
        const grid = grid_make(3, 3);
        console.assert(grid[1][1].nw == grid[0][0]);
        console.assert(grid[1][1].n == grid[0][1]);
        console.assert(grid[1][1].ne == grid[0][2]);
        console.assert(grid[1][1].w == grid[1][0]);
        console.assert(grid[1][1].e == grid[1][2]);
        console.assert(grid[1][1].sw == grid[2][0]);
        console.assert(grid[1][1].s == grid[2][1]);
        console.assert(grid[1][1].se == grid[2][2]);
    }

    // ch2state maps a character to a cell state.
    const ch2state = {
        "u": kCellStateUnopened,
        "o": kCellStateOpened,
        "f": kCellStateFlagged
    };

    // state2ch maps a cell state to a character.
    let state2ch = {};
    for (k in ch2state) {
        let v = ch2state[k];
        state2ch[v] = k;
    }

    function grid2str(grid) {
        let ret = "";
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                ret += state2ch[grid[i][j].state];
            }
            ret += "\n";
        }
        return ret;
    }

    function assert_states(grid, expected_states) {
        console.assert(grid.length == expected_states.length, "Expected expected_states.length == %d. Bad test input?", grid.length);
        for (let i = 0; i < grid.length; i++) {
            console.assert(grid[i].length == expected_states[i].length, "Expected expected_states[%d].length == %d. Bad test input?", i, grid[i].length);
            for (let j = 0; j < grid[i].length; j++) {
                let expected_state_ch = expected_states[i][j];
                console.assert(expected_state_ch in ch2state, "Expected state %s to be in %o", expected_state_ch, Object.keys(ch2state));
                let expected_state = ch2state[expected_state_ch];
                console.assert(grid[i][j].state == expected_state, "Expected (%d, %d) to be state %s, got %s\nExpected Grid\n%s\nGot Grid:\n%s\n", i, j, expected_state_ch, state2ch[grid[i][j].state], expected_states.join("\n"), grid2str(grid));
            }
        }
    }

    function test_reveal() {
        // Reveal returns false on a mine, true on non-mine.
        {
            const grid = grid_make(3, 3);
            grid[0][0].is_mine = true;
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(cell_reveal(grid[1][0]));
        }
        // Reveal recursively reveals.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            assert_states(grid, [
                "uu",
                "uu",
                "uu"
            ]);
            console.assert(cell_reveal(grid[2][1]));
            assert_states(grid, [
                "uu",
                "oo",
                "oo"
            ]);
        }
    }

    function test_chord() {
        // Chord does nothing if no flagged neighbors.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
            // Attempting to chord does nothing.
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "uo",
                "uu",
                "uu"
            ]);
        }
        // Chord reveals if number of flagged neighbors is equal to number of mines.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "uu",
                "uu"
            ]);
            // After flagging the mine, chording reveals.
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "oo",
                "uu"
            ]);
            // Chord works again.
            console.assert(cell_chord(grid[1][1]).ok);
            assert_states(grid, [
                "fo",
                "oo",
                "oo"
            ]);
        }

        // Chord returns false if a mine is revealed.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "uo",
                "fu",
                "uu"
            ]);
            // After flagging the incorrect mine, chording reveals and returns false.
            console.assert(!cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "oo",
                "fo",
                "uu"
            ]);
        }

        // Chord does not reveal neighbors if number of flagged neighbors is greater than number of mines.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
        }

        // Chord does not recursively chord.
        // Q: Is this consistent with other minesweeper games?
        // A: Yes. Checked with minesweeper-x.
        {
            const grid = grid_make(3, 2);
            grid[0][0].is_mine = true;
            grid[1][0].is_mine = true;
            console.assert(cell_reveal(grid[0][1]));
            grid[0][0].state = kCellStateFlagged;
            grid[1][0].state = kCellStateFlagged;
            assert_states(grid, [
                "fo",
                "fu",
                "uu"
            ]);
            console.assert(cell_chord(grid[0][1]).ok);
            assert_states(grid, [
                "fo",
                "fo",
                "uu"
            ]);
        }
    }

    function test_grid_state() {
        // Grid is won once all non-mine cells are revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(cell_reveal(grid[0][1]));
            console.assert(cell_reveal(grid[1][0]));
            console.assert(cell_reveal(grid[1][1]));
            console.assert(grid_state(grid) == kGridStateWon);
        }
        // Grid is lost once a mine cells is revealed.
        {
            const grid = grid_make(2, 2);
            grid[0][0].is_mine = true;
            console.assert(grid_state(grid) == kGridStateInProgress);
            console.assert(!cell_reveal(grid[0][0]));
            console.assert(grid_state(grid) == kGridStateLost);
        }
    }

    function test_grid_set_mines() {
        // Mines are not set on starting position.
        {
            const grid = grid_make(2, 2);
            grid_set_mines(grid, 0, 0, 3);
            console.assert(!grid[0][0].is_mine);
            console.assert(grid[1][0].is_mine);
            console.assert(grid[0][1].is_mine);
            console.assert(grid[1][1].is_mine);
        }
    }


    function run_tests() {
        test_grid_make();
        test_reveal();
        test_chord();
        test_grid_state();
        test_grid_set_mines();
        let g = game_make();
        g.selftest();
    }

    run_tests();

    // Testing ... end
</script>

</html>